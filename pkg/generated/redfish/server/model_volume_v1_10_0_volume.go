// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Redfish
 *
 * This contains the definition of a Redfish service.
 *
 * API version: 2023.3
 */

package server

// VolumeV1100Volume - Volume contains properties used to describe a volume, virtual disk, LUN, or other logical storage entity for any system.
type VolumeV1100Volume struct {

	// The OData description of a payload.
	OdataContext string `json:"@odata.context,omitempty"`

	// The current ETag of the resource.
	OdataEtag string `json:"@odata.etag,omitempty"`

	// The unique identifier for a resource.
	OdataId string `json:"@odata.id"`

	// The type of a resource.
	OdataType string `json:"@odata.type"`

	ALUA *VolumeV1100Alua `json:"ALUA,omitempty"`

	// Supported IO access capabilities.
	AccessCapabilities []VolumeV1100VolumeAccessCapabilitiesInner `json:"AccessCapabilities,omitempty"`

	Actions VolumeV1100Actions `json:"Actions,omitempty"`

	AllocatedPools OdataV4IdRef `json:"AllocatedPools,omitempty"`

	// The size of the smallest addressable unit (Block) of this volume in bytes.
	BlockSizeBytes *int64 `json:"BlockSizeBytes,omitempty"`

	Capacity CapacityV100Capacity `json:"Capacity,omitempty"`

	// The size in bytes of this Volume.
	CapacityBytes *int64 `json:"CapacityBytes,omitempty"`

	// An array of space allocations to this volume.
	CapacitySources []CapacityCapacitySource `json:"CapacitySources,omitempty"`

	// The number of items in a collection.
	CapacitySourcesodataCount int64 `json:"CapacitySources@odata.count,omitempty"`

	// Indicator of whether or not the Volume has compression enabled.
	Compressed *bool `json:"Compressed,omitempty"`

	// An array of references to Connections that includes this volume.
	Connections []OdataV4IdRef `json:"Connections,omitempty"`

	// The number of items in a collection.
	ConnectionsodataCount int64 `json:"Connections@odata.count,omitempty"`

	// Indicator of whether or not the Volume has deduplication enabled.
	Deduplicated *bool `json:"Deduplicated,omitempty"`

	// The description of this resource.  Used for commonality in the schema definitions.
	Description string `json:"Description,omitempty"`

	// A user-configurable string to name the volume.
	DisplayName *string `json:"DisplayName,omitempty"`

	// Is this Volume encrypted.
	Encrypted *bool `json:"Encrypted,omitempty"`

	// The types of encryption used by this Volume.
	EncryptionTypes []VolumeEncryptionTypes `json:"EncryptionTypes,omitempty"`

	// Indicates the IO performance mode setting for the volume.
	IOPerfModeEnabled *bool `json:"IOPerfModeEnabled,omitempty"`

	IOStatistics IoStatisticsIoStatistics `json:"IOStatistics,omitempty"`

	// The unique identifier for this resource within the collection of similar resources.
	Id string `json:"Id"`

	// The Durable names for the volume.
	Identifiers []ResourceIdentifier `json:"Identifiers,omitempty"`

	InitializeMethod *VolumeInitializeMethod `json:"InitializeMethod,omitempty"`

	// This property indicates whether or not the Volume contains a boot image and is capable of booting.
	IsBootCapable *bool `json:"IsBootCapable,omitempty"`

	Links VolumeV1100Links `json:"Links,omitempty"`

	// Indicates the host-visible LogicalUnitNumber assigned to this Volume.
	LogicalUnitNumber *int64 `json:"LogicalUnitNumber,omitempty"`

	// Low space warning.
	LowSpaceWarningThresholdPercents []*int64 `json:"LowSpaceWarningThresholdPercents,omitempty"`

	// The manufacturer or OEM of this storage volume.
	Manufacturer *string `json:"Manufacturer,omitempty"`

	// Max Block size in bytes.
	MaxBlockSizeBytes *int64 `json:"MaxBlockSizeBytes,omitempty"`

	// Indicates the number of media elements used per span in the secondary RAID for a hierarchical RAID type.
	MediaSpanCount *int64 `json:"MediaSpanCount,omitempty"`

	Metrics OdataV4IdRef `json:"Metrics,omitempty"`

	// The model number for this storage volume.
	Model *string `json:"Model,omitempty"`

	NVMeNamespaceProperties *VolumeV1100NvmeNamespaceProperties `json:"NVMeNamespaceProperties,omitempty"`

	// The name of the resource or array member.
	Name string `json:"Name"`

	// The OEM extension.
	Oem map[string]interface{} `json:"Oem,omitempty"`

	// The operations currently running on the Volume.
	Operations []VolumeV1100Operation `json:"Operations,omitempty"`

	// The size in bytes of this Volume's optimum IO size.
	OptimumIOSizeBytes *int64 `json:"OptimumIOSizeBytes,omitempty"`

	ProvisioningPolicy *DataStorageLoSCapabilitiesProvisioningPolicy `json:"ProvisioningPolicy,omitempty"`

	RAIDType *VolumeRaidType `json:"RAIDType,omitempty"`

	ReadCachePolicy *VolumeReadCachePolicyType `json:"ReadCachePolicy,omitempty"`

	// Current number of capacity source resources that are available as replacements.
	RecoverableCapacitySourceCount *int64 `json:"RecoverableCapacitySourceCount,omitempty"`

	// The percentage of the capacity remaining in the Volume.
	RemainingCapacityPercent *int64 `json:"RemainingCapacityPercent,omitempty"`

	// URIs to the resources that are remote target replicas of this source.
	RemoteReplicaTargets []*string `json:"RemoteReplicaTargets,omitempty"`

	ReplicaInfo StorageReplicaInfoV140ReplicaInfo `json:"ReplicaInfo,omitempty"`

	// The resources that are target replicas of this source.
	ReplicaTargets []OdataV4IdRef `json:"ReplicaTargets,omitempty"`

	// The number of items in a collection.
	ReplicaTargetsodataCount int64 `json:"ReplicaTargets@odata.count,omitempty"`

	// Indicates whether or not replication is enabled on the volume.
	ReplicationEnabled *bool `json:"ReplicationEnabled,omitempty"`

	Status ResourceStatus `json:"Status,omitempty"`

	StorageGroups OdataV4IdRef `json:"StorageGroups,omitempty"`

	// The number of blocks (bytes) in a strip in a disk array that uses striped data mapping.
	StripSizeBytes *int64 `json:"StripSizeBytes,omitempty"`

	VolumeType *VolumeVolumeType `json:"VolumeType,omitempty"`

	VolumeUsage *VolumeVolumeUsageType `json:"VolumeUsage,omitempty"`

	WriteCachePolicy *VolumeWriteCachePolicyType `json:"WriteCachePolicy,omitempty"`

	WriteCacheState *VolumeWriteCacheStateType `json:"WriteCacheState,omitempty"`

	WriteHoleProtectionPolicy VolumeWriteHoleProtectionPolicyType `json:"WriteHoleProtectionPolicy,omitempty"`
}

// AssertVolumeV1100VolumeRequired checks if the required fields are not zero-ed
func AssertVolumeV1100VolumeRequired(obj VolumeV1100Volume) error {
	elements := map[string]interface{}{
		"@odata.id":   obj.OdataId,
		"@odata.type": obj.OdataType,
		"Id":          obj.Id,
		"Name":        obj.Name,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	if obj.ALUA != nil {
		if err := AssertVolumeV1100AluaRequired(*obj.ALUA); err != nil {
			return err
		}
	}
	for _, el := range obj.AccessCapabilities {
		if err := AssertVolumeV1100VolumeAccessCapabilitiesInnerRequired(el); err != nil {
			return err
		}
	}
	if err := AssertVolumeV1100ActionsRequired(obj.Actions); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefRequired(obj.AllocatedPools); err != nil {
		return err
	}
	if err := AssertCapacityV100CapacityRequired(obj.Capacity); err != nil {
		return err
	}
	for _, el := range obj.CapacitySources {
		if err := AssertCapacityCapacitySourceRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Connections {
		if err := AssertOdataV4IdRefRequired(el); err != nil {
			return err
		}
	}
	if err := AssertIoStatisticsIoStatisticsRequired(obj.IOStatistics); err != nil {
		return err
	}
	for _, el := range obj.Identifiers {
		if err := AssertResourceIdentifierRequired(el); err != nil {
			return err
		}
	}
	if err := AssertVolumeV1100LinksRequired(obj.Links); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefRequired(obj.Metrics); err != nil {
		return err
	}
	if obj.NVMeNamespaceProperties != nil {
		if err := AssertVolumeV1100NvmeNamespacePropertiesRequired(*obj.NVMeNamespaceProperties); err != nil {
			return err
		}
	}
	for _, el := range obj.Operations {
		if err := AssertVolumeV1100OperationRequired(el); err != nil {
			return err
		}
	}
	if err := AssertStorageReplicaInfoV140ReplicaInfoRequired(obj.ReplicaInfo); err != nil {
		return err
	}
	for _, el := range obj.ReplicaTargets {
		if err := AssertOdataV4IdRefRequired(el); err != nil {
			return err
		}
	}
	if err := AssertResourceStatusRequired(obj.Status); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefRequired(obj.StorageGroups); err != nil {
		return err
	}
	return nil
}

// AssertVolumeV1100VolumeConstraints checks if the values respects the defined constraints
func AssertVolumeV1100VolumeConstraints(obj VolumeV1100Volume) error {
	if obj.ALUA != nil {
		if err := AssertVolumeV1100AluaConstraints(*obj.ALUA); err != nil {
			return err
		}
	}
	for _, el := range obj.AccessCapabilities {
		if err := AssertVolumeV1100VolumeAccessCapabilitiesInnerConstraints(el); err != nil {
			return err
		}
	}
	if err := AssertVolumeV1100ActionsConstraints(obj.Actions); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefConstraints(obj.AllocatedPools); err != nil {
		return err
	}
	if err := AssertCapacityV100CapacityConstraints(obj.Capacity); err != nil {
		return err
	}
	for _, el := range obj.CapacitySources {
		if err := AssertCapacityCapacitySourceConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Connections {
		if err := AssertOdataV4IdRefConstraints(el); err != nil {
			return err
		}
	}
	if err := AssertIoStatisticsIoStatisticsConstraints(obj.IOStatistics); err != nil {
		return err
	}
	for _, el := range obj.Identifiers {
		if err := AssertResourceIdentifierConstraints(el); err != nil {
			return err
		}
	}
	if err := AssertVolumeV1100LinksConstraints(obj.Links); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefConstraints(obj.Metrics); err != nil {
		return err
	}
	if obj.NVMeNamespaceProperties != nil {
		if err := AssertVolumeV1100NvmeNamespacePropertiesConstraints(*obj.NVMeNamespaceProperties); err != nil {
			return err
		}
	}
	for _, el := range obj.Operations {
		if err := AssertVolumeV1100OperationConstraints(el); err != nil {
			return err
		}
	}
	if err := AssertStorageReplicaInfoV140ReplicaInfoConstraints(obj.ReplicaInfo); err != nil {
		return err
	}
	for _, el := range obj.ReplicaTargets {
		if err := AssertOdataV4IdRefConstraints(el); err != nil {
			return err
		}
	}
	if err := AssertResourceStatusConstraints(obj.Status); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefConstraints(obj.StorageGroups); err != nil {
		return err
	}
	return nil
}
