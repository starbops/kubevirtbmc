// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Redfish
 *
 * This contains the definition of a Redfish service.
 *
 * API version: 2023.3
 */

package server

// AggregationServiceV102AggregationService - The AggregationService schema contains properties for managing aggregation operations, either on ad hoc combinations of resources or on defined sets of resources called aggregates.  Access points define the properties needed to access the entity being aggregated and connection methods describe the protocol or other semantics of the connection.
type AggregationServiceV102AggregationService struct {

	// The OData description of a payload.
	OdataContext string `json:"@odata.context,omitempty"`

	// The current ETag of the resource.
	OdataEtag string `json:"@odata.etag,omitempty"`

	// The unique identifier for a resource.
	OdataId string `json:"@odata.id"`

	// The type of a resource.
	OdataType string `json:"@odata.type"`

	Actions AggregationServiceV102Actions `json:"Actions,omitempty"`

	Aggregates OdataV4IdRef `json:"Aggregates,omitempty"`

	AggregationSources OdataV4IdRef `json:"AggregationSources,omitempty"`

	ConnectionMethods OdataV4IdRef `json:"ConnectionMethods,omitempty"`

	// The description of this resource.  Used for commonality in the schema definitions.
	Description string `json:"Description,omitempty"`

	// The unique identifier for this resource within the collection of similar resources.
	Id string `json:"Id"`

	// The name of the resource or array member.
	Name string `json:"Name"`

	// The OEM extension.
	Oem map[string]interface{} `json:"Oem,omitempty"`

	// An indication of whether the aggregation service is enabled.
	ServiceEnabled *bool `json:"ServiceEnabled,omitempty"`

	Status ResourceStatus `json:"Status,omitempty"`
}

// AssertAggregationServiceV102AggregationServiceRequired checks if the required fields are not zero-ed
func AssertAggregationServiceV102AggregationServiceRequired(obj AggregationServiceV102AggregationService) error {
	elements := map[string]interface{}{
		"@odata.id":   obj.OdataId,
		"@odata.type": obj.OdataType,
		"Id":          obj.Id,
		"Name":        obj.Name,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	if err := AssertAggregationServiceV102ActionsRequired(obj.Actions); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefRequired(obj.Aggregates); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefRequired(obj.AggregationSources); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefRequired(obj.ConnectionMethods); err != nil {
		return err
	}
	if err := AssertResourceStatusRequired(obj.Status); err != nil {
		return err
	}
	return nil
}

// AssertAggregationServiceV102AggregationServiceConstraints checks if the values respects the defined constraints
func AssertAggregationServiceV102AggregationServiceConstraints(obj AggregationServiceV102AggregationService) error {
	if err := AssertAggregationServiceV102ActionsConstraints(obj.Actions); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefConstraints(obj.Aggregates); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefConstraints(obj.AggregationSources); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefConstraints(obj.ConnectionMethods); err != nil {
		return err
	}
	if err := AssertResourceStatusConstraints(obj.Status); err != nil {
		return err
	}
	return nil
}
