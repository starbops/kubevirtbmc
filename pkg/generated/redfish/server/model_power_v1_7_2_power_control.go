// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Redfish
 *
 * This contains the definition of a Redfish service.
 *
 * API version: 2023.3
 */

package server

import (
	"errors"
)

type PowerV172PowerControl struct {

	// The unique identifier for a resource.
	OdataId string `json:"@odata.id"`

	Actions PowerV172PowerControlActions `json:"Actions,omitempty"`

	// The unique identifier for the member within an array.
	MemberId string `json:"MemberId"`

	// The power control function name.
	Name *string `json:"Name,omitempty"`

	// The OEM extension.
	Oem map[string]interface{} `json:"Oem,omitempty"`

	PhysicalContext PhysicalContextPhysicalContext `json:"PhysicalContext,omitempty"`

	// The total amount of power that has been allocated or budgeted to chassis.
	PowerAllocatedWatts *float32 `json:"PowerAllocatedWatts,omitempty"`

	// The amount of reserve power capacity, in watt units, that remains.  This value is the PowerCapacityWatts value minus the PowerAllocatedWatts value.
	PowerAvailableWatts *float32 `json:"PowerAvailableWatts,omitempty"`

	// The total amount of power that can be allocated to the chassis.  This value can be either the power supply capacity or the power budget that an upstream chassis assigns to this chassis.
	PowerCapacityWatts *float32 `json:"PowerCapacityWatts,omitempty"`

	// The actual power that the chassis consumes, in watt units.
	PowerConsumedWatts *float32 `json:"PowerConsumedWatts,omitempty"`

	PowerLimit PowerV172PowerLimit `json:"PowerLimit,omitempty"`

	PowerMetrics PowerV172PowerMetric `json:"PowerMetrics,omitempty"`

	// The potential power, in watt units, that the chassis requests, which might be higher than the current level being consumed because the requested power includes a budget that the chassis wants for future use.
	PowerRequestedWatts *float32 `json:"PowerRequestedWatts,omitempty"`

	// An array of links to resources or objects associated with this power limit.
	RelatedItem []OdataV4IdRef `json:"RelatedItem,omitempty"`

	// The number of items in a collection.
	RelatedItemodataCount int64 `json:"RelatedItem@odata.count,omitempty"`

	Status ResourceStatus `json:"Status,omitempty"`
}

// AssertPowerV172PowerControlRequired checks if the required fields are not zero-ed
func AssertPowerV172PowerControlRequired(obj PowerV172PowerControl) error {
	elements := map[string]interface{}{
		"@odata.id": obj.OdataId,
		"MemberId":  obj.MemberId,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	if err := AssertPowerV172PowerControlActionsRequired(obj.Actions); err != nil {
		return err
	}
	if err := AssertPowerV172PowerLimitRequired(obj.PowerLimit); err != nil {
		return err
	}
	if err := AssertPowerV172PowerMetricRequired(obj.PowerMetrics); err != nil {
		return err
	}
	for _, el := range obj.RelatedItem {
		if err := AssertOdataV4IdRefRequired(el); err != nil {
			return err
		}
	}
	if err := AssertResourceStatusRequired(obj.Status); err != nil {
		return err
	}
	return nil
}

// AssertPowerV172PowerControlConstraints checks if the values respects the defined constraints
func AssertPowerV172PowerControlConstraints(obj PowerV172PowerControl) error {
	if err := AssertPowerV172PowerControlActionsConstraints(obj.Actions); err != nil {
		return err
	}
	if obj.PowerAllocatedWatts != nil && *obj.PowerAllocatedWatts < 0 {
		return &ParsingError{Param: "PowerAllocatedWatts", Err: errors.New(errMsgMinValueConstraint)}
	}
	if obj.PowerAvailableWatts != nil && *obj.PowerAvailableWatts < 0 {
		return &ParsingError{Param: "PowerAvailableWatts", Err: errors.New(errMsgMinValueConstraint)}
	}
	if obj.PowerCapacityWatts != nil && *obj.PowerCapacityWatts < 0 {
		return &ParsingError{Param: "PowerCapacityWatts", Err: errors.New(errMsgMinValueConstraint)}
	}
	if obj.PowerConsumedWatts != nil && *obj.PowerConsumedWatts < 0 {
		return &ParsingError{Param: "PowerConsumedWatts", Err: errors.New(errMsgMinValueConstraint)}
	}
	if err := AssertPowerV172PowerLimitConstraints(obj.PowerLimit); err != nil {
		return err
	}
	if err := AssertPowerV172PowerMetricConstraints(obj.PowerMetrics); err != nil {
		return err
	}
	if obj.PowerRequestedWatts != nil && *obj.PowerRequestedWatts < 0 {
		return &ParsingError{Param: "PowerRequestedWatts", Err: errors.New(errMsgMinValueConstraint)}
	}
	for _, el := range obj.RelatedItem {
		if err := AssertOdataV4IdRefConstraints(el); err != nil {
			return err
		}
	}
	if err := AssertResourceStatusConstraints(obj.Status); err != nil {
		return err
	}
	return nil
}
