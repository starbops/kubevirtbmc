// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Redfish
 *
 * This contains the definition of a Redfish service.
 *
 * API version: 2023.3
 */

package server

import (
	"errors"
)

// PowerSubsystemV111PowerSubsystem - This PowerSubsystem schema contains the definition for the power subsystem of a chassis.
type PowerSubsystemV111PowerSubsystem struct {

	// The OData description of a payload.
	OdataContext string `json:"@odata.context,omitempty"`

	// The current ETag of the resource.
	OdataEtag string `json:"@odata.etag,omitempty"`

	// The unique identifier for a resource.
	OdataId string `json:"@odata.id"`

	// The type of a resource.
	OdataType string `json:"@odata.type"`

	Actions PowerSubsystemV111Actions `json:"Actions,omitempty"`

	Allocation PowerSubsystemV111PowerAllocation `json:"Allocation,omitempty"`

	Batteries OdataV4IdRef `json:"Batteries,omitempty"`

	// The total amount of power that can be allocated to this subsystem.  This value can be either the power supply capacity or the power budget that an upstream chassis assigns to this subsystem.
	CapacityWatts *float32 `json:"CapacityWatts,omitempty"`

	// The description of this resource.  Used for commonality in the schema definitions.
	Description string `json:"Description,omitempty"`

	// The unique identifier for this resource within the collection of similar resources.
	Id string `json:"Id"`

	// The name of the resource or array member.
	Name string `json:"Name"`

	// The OEM extension.
	Oem map[string]interface{} `json:"Oem,omitempty"`

	PowerSupplies OdataV4IdRef `json:"PowerSupplies,omitempty"`

	// The redundancy information for the set of power supplies in this subsystem.
	PowerSupplyRedundancy []RedundancyRedundantGroup `json:"PowerSupplyRedundancy,omitempty"`

	Status ResourceStatus `json:"Status,omitempty"`
}

// AssertPowerSubsystemV111PowerSubsystemRequired checks if the required fields are not zero-ed
func AssertPowerSubsystemV111PowerSubsystemRequired(obj PowerSubsystemV111PowerSubsystem) error {
	elements := map[string]interface{}{
		"@odata.id":   obj.OdataId,
		"@odata.type": obj.OdataType,
		"Id":          obj.Id,
		"Name":        obj.Name,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	if err := AssertPowerSubsystemV111ActionsRequired(obj.Actions); err != nil {
		return err
	}
	if err := AssertPowerSubsystemV111PowerAllocationRequired(obj.Allocation); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefRequired(obj.Batteries); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefRequired(obj.PowerSupplies); err != nil {
		return err
	}
	for _, el := range obj.PowerSupplyRedundancy {
		if err := AssertRedundancyRedundantGroupRequired(el); err != nil {
			return err
		}
	}
	if err := AssertResourceStatusRequired(obj.Status); err != nil {
		return err
	}
	return nil
}

// AssertPowerSubsystemV111PowerSubsystemConstraints checks if the values respects the defined constraints
func AssertPowerSubsystemV111PowerSubsystemConstraints(obj PowerSubsystemV111PowerSubsystem) error {
	if err := AssertPowerSubsystemV111ActionsConstraints(obj.Actions); err != nil {
		return err
	}
	if err := AssertPowerSubsystemV111PowerAllocationConstraints(obj.Allocation); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefConstraints(obj.Batteries); err != nil {
		return err
	}
	if obj.CapacityWatts != nil && *obj.CapacityWatts < 0 {
		return &ParsingError{Param: "CapacityWatts", Err: errors.New(errMsgMinValueConstraint)}
	}
	if err := AssertOdataV4IdRefConstraints(obj.PowerSupplies); err != nil {
		return err
	}
	for _, el := range obj.PowerSupplyRedundancy {
		if err := AssertRedundancyRedundantGroupConstraints(el); err != nil {
			return err
		}
	}
	if err := AssertResourceStatusConstraints(obj.Status); err != nil {
		return err
	}
	return nil
}
