// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Redfish
 *
 * This contains the definition of a Redfish service.
 *
 * API version: 2023.3
 */

package server

import (
	"errors"
)

// DriveV1180Drive - The Drive schema represents a single physical drive for a system, including links to associated volumes.  It also describes the location, such as a slot, socket, or bay, where a unit can be installed, by populating a resource instance with an absent state if a unit is not present.
type DriveV1180Drive struct {

	// The OData description of a payload.
	OdataContext string `json:"@odata.context,omitempty"`

	// The current ETag of the resource.
	OdataEtag string `json:"@odata.etag,omitempty"`

	// The unique identifier for a resource.
	OdataId string `json:"@odata.id"`

	// The type of a resource.
	OdataType string `json:"@odata.type"`

	Actions DriveV1180Actions `json:"Actions,omitempty"`

	Assembly OdataV4IdRef `json:"Assembly,omitempty"`

	// The user-assigned asset tag for this drive.
	AssetTag *string `json:"AssetTag,omitempty"`

	// The size, in bytes, of the smallest addressable unit, or block.
	BlockSizeBytes *int64 `json:"BlockSizeBytes,omitempty"`

	// The speed, in gigabits per second (Gbit/s) units, at which this drive can communicate to a storage controller in ideal conditions.
	CapableSpeedGbs *float32 `json:"CapableSpeedGbs,omitempty"`

	// The size, in bytes, of this drive.
	CapacityBytes *int64 `json:"CapacityBytes,omitempty"`

	Certificates OdataV4IdRef `json:"Certificates,omitempty"`

	// The description of this resource.  Used for commonality in the schema definitions.
	Description string `json:"Description,omitempty"`

	DriveFormFactor DriveV1180FormFactor `json:"DriveFormFactor,omitempty"`

	EncryptionAbility DriveV1180EncryptionAbility `json:"EncryptionAbility,omitempty"`

	EncryptionStatus DriveV1180EncryptionStatus `json:"EncryptionStatus,omitempty"`

	EnvironmentMetrics OdataV4IdRef `json:"EnvironmentMetrics,omitempty"`

	// An indication of whether this drive currently predicts a failure in the near future.
	FailurePredicted *bool `json:"FailurePredicted,omitempty"`

	// The firmware version for this drive.
	FirmwareVersion *string `json:"FirmwareVersion,omitempty"`

	HotspareReplacementMode DriveV1180HotspareReplacementModeType `json:"HotspareReplacementMode,omitempty"`

	HotspareType DriveV1180HotspareType `json:"HotspareType,omitempty"`

	// The unique identifier for this resource within the collection of similar resources.
	Id string `json:"Id"`

	// The durable names for the drive.
	Identifiers []ResourceIdentifier `json:"Identifiers,omitempty"`

	IndicatorLED ResourceIndicatorLed `json:"IndicatorLED,omitempty"`

	Links DriveV1180Links `json:"Links,omitempty"`

	// The location of the drive.
	// Deprecated
	Location []ResourceLocation `json:"Location,omitempty"`

	// An indicator allowing an operator to physically locate this resource.
	LocationIndicatorActive *bool `json:"LocationIndicatorActive,omitempty"`

	// The manufacturer of this drive.
	Manufacturer *string `json:"Manufacturer,omitempty"`

	// An array of DSP0274-defined measurement blocks.
	// Deprecated
	Measurements []SoftwareInventoryMeasurementBlock `json:"Measurements,omitempty"`

	MediaType DriveV1180MediaType `json:"MediaType,omitempty"`

	Metrics OdataV4IdRef `json:"Metrics,omitempty"`

	// The model number for the drive.
	Model *string `json:"Model,omitempty"`

	// An indication of whether the drive is accessible from multiple paths.
	Multipath *bool `json:"Multipath,omitempty"`

	// The name of the resource or array member.
	Name string `json:"Name"`

	// The speed, in gigabits per second (Gbit/s) units, at which this drive currently communicates to the storage controller.
	NegotiatedSpeedGbs *float32 `json:"NegotiatedSpeedGbs,omitempty"`

	// The OEM extension.
	Oem map[string]interface{} `json:"Oem,omitempty"`

	// The operations currently running on the Drive.
	Operations []DriveV1180Operations `json:"Operations,omitempty"`

	// The part number for this drive.
	PartNumber *string `json:"PartNumber,omitempty"`

	PhysicalLocation ResourceLocation `json:"PhysicalLocation,omitempty"`

	// The percentage of reads and writes that are predicted to be available for the media.
	PredictedMediaLifeLeftPercent *float32 `json:"PredictedMediaLifeLeftPercent,omitempty"`

	Protocol ProtocolProtocol `json:"Protocol,omitempty"`

	// An indication of whether the drive is prepared by the system for removal.
	ReadyToRemove *bool `json:"ReadyToRemove,omitempty"`

	// The revision of this drive.  For SCSI-based drives, this is the version of the drive from the 'Inquiry' command, which can be the firmware or hardware version.  For other types of drives, this is the hardware version.
	Revision *string `json:"Revision,omitempty"`

	// The rotation speed of this drive, in revolutions per minute (RPM) units.
	RotationSpeedRPM *float32 `json:"RotationSpeedRPM,omitempty"`

	// The SKU for this drive.
	SKU *string `json:"SKU,omitempty"`

	// The serial number for this drive.
	SerialNumber *string `json:"SerialNumber,omitempty"`

	// The drive protocols capable in this slot.
	SlotCapableProtocols []ProtocolProtocol `json:"SlotCapableProtocols,omitempty"`

	SlotFormFactor DriveV1180FormFactor `json:"SlotFormFactor,omitempty"`

	Status ResourceStatus `json:"Status,omitempty"`

	StatusIndicator DriveV1180StatusIndicator `json:"StatusIndicator,omitempty"`

	// An indication of whether the drive write cache is enabled.
	WriteCacheEnabled *bool `json:"WriteCacheEnabled,omitempty"`
}

// AssertDriveV1180DriveRequired checks if the required fields are not zero-ed
func AssertDriveV1180DriveRequired(obj DriveV1180Drive) error {
	elements := map[string]interface{}{
		"@odata.id":   obj.OdataId,
		"@odata.type": obj.OdataType,
		"Id":          obj.Id,
		"Name":        obj.Name,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	if err := AssertDriveV1180ActionsRequired(obj.Actions); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefRequired(obj.Assembly); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefRequired(obj.Certificates); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefRequired(obj.EnvironmentMetrics); err != nil {
		return err
	}
	for _, el := range obj.Identifiers {
		if err := AssertResourceIdentifierRequired(el); err != nil {
			return err
		}
	}
	if err := AssertDriveV1180LinksRequired(obj.Links); err != nil {
		return err
	}
	for _, el := range obj.Location {
		if err := AssertResourceLocationRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Measurements {
		if err := AssertSoftwareInventoryMeasurementBlockRequired(el); err != nil {
			return err
		}
	}
	if err := AssertOdataV4IdRefRequired(obj.Metrics); err != nil {
		return err
	}
	for _, el := range obj.Operations {
		if err := AssertDriveV1180OperationsRequired(el); err != nil {
			return err
		}
	}
	if err := AssertResourceLocationRequired(obj.PhysicalLocation); err != nil {
		return err
	}
	if err := AssertResourceStatusRequired(obj.Status); err != nil {
		return err
	}
	return nil
}

// AssertDriveV1180DriveConstraints checks if the values respects the defined constraints
func AssertDriveV1180DriveConstraints(obj DriveV1180Drive) error {
	if err := AssertDriveV1180ActionsConstraints(obj.Actions); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefConstraints(obj.Assembly); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefConstraints(obj.Certificates); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefConstraints(obj.EnvironmentMetrics); err != nil {
		return err
	}
	for _, el := range obj.Identifiers {
		if err := AssertResourceIdentifierConstraints(el); err != nil {
			return err
		}
	}
	if err := AssertDriveV1180LinksConstraints(obj.Links); err != nil {
		return err
	}
	for _, el := range obj.Location {
		if err := AssertResourceLocationConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Measurements {
		if err := AssertSoftwareInventoryMeasurementBlockConstraints(el); err != nil {
			return err
		}
	}
	if err := AssertOdataV4IdRefConstraints(obj.Metrics); err != nil {
		return err
	}
	for _, el := range obj.Operations {
		if err := AssertDriveV1180OperationsConstraints(el); err != nil {
			return err
		}
	}
	if err := AssertResourceLocationConstraints(obj.PhysicalLocation); err != nil {
		return err
	}
	if obj.PredictedMediaLifeLeftPercent != nil && *obj.PredictedMediaLifeLeftPercent < 0 {
		return &ParsingError{Param: "PredictedMediaLifeLeftPercent", Err: errors.New(errMsgMinValueConstraint)}
	}
	if err := AssertResourceStatusConstraints(obj.Status); err != nil {
		return err
	}
	return nil
}
