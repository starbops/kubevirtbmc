// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

/*
 * Redfish
 *
 * This contains the definition of a Redfish service.
 *
 * API version: 2023.3
 */

package server

// VolumeV1100Links - Add ability to manage spare capacity.
type VolumeV1100Links struct {

	// A pointer to the data volumes this volume serves as a cache volume.
	CacheDataVolumes []OdataV4IdRef `json:"CacheDataVolumes,omitempty"`

	// The number of items in a collection.
	CacheDataVolumesodataCount int64 `json:"CacheDataVolumes@odata.count,omitempty"`

	CacheVolumeSource *OdataV4IdRef `json:"CacheVolumeSource,omitempty"`

	ClassOfService OdataV4IdRef `json:"ClassOfService,omitempty"`

	// An array of references to the client Endpoints associated with this volume.
	ClientEndpoints []OdataV4IdRef `json:"ClientEndpoints,omitempty"`

	// The number of items in a collection.
	ClientEndpointsodataCount int64 `json:"ClientEndpoints@odata.count,omitempty"`

	// An array of references to the ConsistencyGroups associated with this volume.
	ConsistencyGroups []OdataV4IdRef `json:"ConsistencyGroups,omitempty"`

	// The number of items in a collection.
	ConsistencyGroupsodataCount int64 `json:"ConsistencyGroups@odata.count,omitempty"`

	// An array of the Controllers associated with this volume.
	Controllers []OdataV4IdRef `json:"Controllers,omitempty"`

	// The number of items in a collection.
	ControllersodataCount int64 `json:"Controllers@odata.count,omitempty"`

	// An array of references to the drives which are dedicated spares for this volume.
	DedicatedSpareDrives []OdataV4IdRef `json:"DedicatedSpareDrives,omitempty"`

	// The number of items in a collection.
	DedicatedSpareDrivesodataCount int64 `json:"DedicatedSpareDrives@odata.count,omitempty"`

	// An array of references to the drives which contain this volume. This will reference Drives that either wholly or only partly contain this volume.
	Drives []OdataV4IdRef `json:"Drives,omitempty"`

	// The number of items in a collection.
	DrivesodataCount int64 `json:"Drives@odata.count,omitempty"`

	JournalingMedia *OdataV4IdRef `json:"JournalingMedia,omitempty"`

	// The OEM extension.
	Oem map[string]interface{} `json:"Oem,omitempty"`

	OwningStorageResource OdataV4IdRef `json:"OwningStorageResource,omitempty"`

	OwningStorageService OdataV4IdRef `json:"OwningStorageService,omitempty"`

	ProvidingStoragePool *OdataV4IdRef `json:"ProvidingStoragePool,omitempty"`

	// An array of references to the server Endpoints associated with this volume.
	ServerEndpoints []OdataV4IdRef `json:"ServerEndpoints,omitempty"`

	// The number of items in a collection.
	ServerEndpointsodataCount int64 `json:"ServerEndpoints@odata.count,omitempty"`

	// An array of references to SpareResourceSets.
	SpareResourceSets []OdataV4IdRef `json:"SpareResourceSets,omitempty"`

	// The number of items in a collection.
	SpareResourceSetsodataCount int64 `json:"SpareResourceSets@odata.count,omitempty"`

	// An array of references to the StorageGroups associated with this volume.
	StorageGroups []OdataV4IdRef `json:"StorageGroups,omitempty"`

	// The number of items in a collection.
	StorageGroupsodataCount int64 `json:"StorageGroups@odata.count,omitempty"`
}

// AssertVolumeV1100LinksRequired checks if the required fields are not zero-ed
func AssertVolumeV1100LinksRequired(obj VolumeV1100Links) error {
	for _, el := range obj.CacheDataVolumes {
		if err := AssertOdataV4IdRefRequired(el); err != nil {
			return err
		}
	}
	if obj.CacheVolumeSource != nil {
		if err := AssertOdataV4IdRefRequired(*obj.CacheVolumeSource); err != nil {
			return err
		}
	}
	if err := AssertOdataV4IdRefRequired(obj.ClassOfService); err != nil {
		return err
	}
	for _, el := range obj.ClientEndpoints {
		if err := AssertOdataV4IdRefRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.ConsistencyGroups {
		if err := AssertOdataV4IdRefRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Controllers {
		if err := AssertOdataV4IdRefRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.DedicatedSpareDrives {
		if err := AssertOdataV4IdRefRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Drives {
		if err := AssertOdataV4IdRefRequired(el); err != nil {
			return err
		}
	}
	if obj.JournalingMedia != nil {
		if err := AssertOdataV4IdRefRequired(*obj.JournalingMedia); err != nil {
			return err
		}
	}
	if err := AssertOdataV4IdRefRequired(obj.OwningStorageResource); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefRequired(obj.OwningStorageService); err != nil {
		return err
	}
	if obj.ProvidingStoragePool != nil {
		if err := AssertOdataV4IdRefRequired(*obj.ProvidingStoragePool); err != nil {
			return err
		}
	}
	for _, el := range obj.ServerEndpoints {
		if err := AssertOdataV4IdRefRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.SpareResourceSets {
		if err := AssertOdataV4IdRefRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.StorageGroups {
		if err := AssertOdataV4IdRefRequired(el); err != nil {
			return err
		}
	}
	return nil
}

// AssertVolumeV1100LinksConstraints checks if the values respects the defined constraints
func AssertVolumeV1100LinksConstraints(obj VolumeV1100Links) error {
	for _, el := range obj.CacheDataVolumes {
		if err := AssertOdataV4IdRefConstraints(el); err != nil {
			return err
		}
	}
	if obj.CacheVolumeSource != nil {
		if err := AssertOdataV4IdRefConstraints(*obj.CacheVolumeSource); err != nil {
			return err
		}
	}
	if err := AssertOdataV4IdRefConstraints(obj.ClassOfService); err != nil {
		return err
	}
	for _, el := range obj.ClientEndpoints {
		if err := AssertOdataV4IdRefConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.ConsistencyGroups {
		if err := AssertOdataV4IdRefConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Controllers {
		if err := AssertOdataV4IdRefConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.DedicatedSpareDrives {
		if err := AssertOdataV4IdRefConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Drives {
		if err := AssertOdataV4IdRefConstraints(el); err != nil {
			return err
		}
	}
	if obj.JournalingMedia != nil {
		if err := AssertOdataV4IdRefConstraints(*obj.JournalingMedia); err != nil {
			return err
		}
	}
	if err := AssertOdataV4IdRefConstraints(obj.OwningStorageResource); err != nil {
		return err
	}
	if err := AssertOdataV4IdRefConstraints(obj.OwningStorageService); err != nil {
		return err
	}
	if obj.ProvidingStoragePool != nil {
		if err := AssertOdataV4IdRefConstraints(*obj.ProvidingStoragePool); err != nil {
			return err
		}
	}
	for _, el := range obj.ServerEndpoints {
		if err := AssertOdataV4IdRefConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.SpareResourceSets {
		if err := AssertOdataV4IdRefConstraints(el); err != nil {
			return err
		}
	}
	for _, el := range obj.StorageGroups {
		if err := AssertOdataV4IdRefConstraints(el); err != nil {
			return err
		}
	}
	return nil
}
